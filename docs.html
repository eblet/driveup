<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DRIVEUP: Скрипт инкрементальных бэкапов Google Drive</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    /* ... (CSS styles remain the same) ... */
    :root {
      --bg-color: #f8f9fa;
      /* Чуть светлее */
      --bg-gradient: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
      /* Градиент для светлой темы */
      --text-color: #212529;
      --heading-color: #0056b3;
      --link-color: #0056b3;
      --border-color: #dee2e6;
      --code-bg-color: #e9ecef;
      --code-text-color: #343a40;
      --pre-bg-color: #fff;
      /* Белый фон для кода */
      --pre-text-color: #343a40;
      --note-bg-color: #fff3cd;
      --note-border-color: #ffeeba;
      --button-bg-color: #fff;
      --button-text-color: #495057;
      --shadow-color: rgba(0, 0, 0, 0.1);
      --icon-fill: #495057;
      --nav-bg-color: #fff;
      --nav-border-color: #dee2e6;
      --nav-shadow-color: rgba(0, 0, 0, 0.05);
    }

    body.dark-theme {
      --bg-color: #212529;
      --bg-gradient: none;
      /* Без градиента в темной теме */
      --text-color: #e9ecef;
      --heading-color: #6cb2f7;
      /* Слегка измененный синий */
      --link-color: #6cb2f7;
      --border-color: #495057;
      --code-bg-color: #495057;
      --code-text-color: #e9ecef;
      --pre-bg-color: #343a40;
      --pre-text-color: #f8f9fa;
      --note-bg-color: #5a4e36;
      /* Темнее */
      --note-border-color: #8c7a51;
      /* Темнее */
      --button-bg-color: #343a40;
      --button-text-color: #e9ecef;
      --shadow-color: rgba(0, 0, 0, 0.3);
      --icon-fill: #e9ecef;
      --nav-bg-color: #343a40;
      --nav-border-color: #495057;
      --nav-shadow-color: rgba(0, 0, 0, 0.2);
    }


    body {
      font-family: 'Google Sans', sans-serif;
      line-height: 1.7;
      margin: 0;
      padding: 40px 20px 60px;
      background-color: var(--bg-color);
      background-image: var(--bg-gradient);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      min-height: 100vh;
      scroll-padding-top: 120px; /* Еще увеличиваем отступ для якорей, тест */
    }

    /* Обертка для центрирования и flex */
    .content-wrapper {
      max-width: 960px; /* Снова немного увеличим для размещения меню */
      margin: 0 auto;
      display: flex; /* Возвращаем Flexbox */
      align-items: flex-start; /* Выравниваем элементы по верху */
      gap: 30px; /* Возвращаем пространство между меню и контентом */
    }

    /* Стили для навигационного меню (TOC) */
    nav.toc {
      /* Убрали: background, border, shadow, padding, border-radius */
      flex-shrink: 0; /* Не сжимать меню, чтобы текст не переносился слишком сильно */
      width: 200px; /* Можно вернуть примерную ширину для column-gap, но без фона/рамки */
      position: sticky; /* Возвращаем \"липкость\" */
      top: 20px; /* Отступ сверху при прилипании */
      align-self: flex-start; /* Чтобы position:sticky работал корректно в flex */
      max-height: calc(100vh - 40px); /* Ограничиваем высоту, чтобы меню не вылезало за экран */
      overflow-y: auto; /* Добавляем скролл, если меню высокое */
    }

    nav.toc h3 {
      margin-top: 0;
      margin-bottom: 8px; /* Уменьшим отступ */
      padding-bottom: 5px;
      border-bottom: 1px solid var(--border-color); /* Вернем разделитель под заголовком TOC */
      font-size: 1em; /* Уменьшим шрифт заголовка */
      color: var(--heading-color);
    }

    nav.toc ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    nav.toc li {
      margin-bottom: 5px; /* Уменьшим отступ */
      padding-left: 0;
    }

    nav.toc li a {
      text-decoration: none;
      color: var(--link-color);
      transition: color 0.2s;
      font-size: 0.85em; /* Уменьшим шрифт ссылок */
      display: block; /* Чтобы ссылка занимала всю ширину li */
      padding: 3px 0; /* Небольшой вертикальный отступ для кликабельности */
    }

    nav.toc li a:hover {
      text-decoration: underline;
      color: var(--heading-color);
    }

    /* Основная область контента */
    main.main-content {
      flex-grow: 1; /* Занимает оставшееся пространство */
      min-width: 0; /* Важно для flex, чтобы контент мог сжиматься */
    }


    h1 { /* Заголовок теперь только для main-content */
      border-bottom: 2px solid var(--heading-color);
      padding-bottom: 15px;
      margin-bottom: 25px;
      font-weight: 700;
    }

    h2 {
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 8px;
      margin-top: 45px;
      margin-bottom: 20px;
    }

    h3:not(nav.toc h3) { /* Применяем стили h3 только вне TOC */
      margin-top: 30px;
      margin-bottom: 15px;
    }

    p {
      margin-bottom: 18px;
    }

    p:last-child {
      margin-bottom: 0;
    }

    a {
      color: var(--link-color);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    code:not(pre code) {
      background-color: var(--code-bg-color);
      color: var(--code-text-color);
      padding: 3px 6px;
      border-radius: 4px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.9em;
      border: 1px solid var(--border-color);
    }

    pre {
      background-color: var(--pre-bg-color);
      color: var(--pre-text-color);
      padding: 18px;
      border-radius: 8px;
      overflow-x: auto;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.9em;
      border: 1px solid var(--border-color);
      white-space: pre;
      word-wrap: normal;
      box-shadow: 0 4px 8px var(--shadow-color);
      margin-top: 10px;
      margin-bottom: 20px;
    }

    pre code {
      background-color: transparent;
      padding: 0;
      border-radius: 0;
      font-size: inherit;
      color: inherit;
      display: block;
      border: none;
    }

    /* Списки */
    ul,
    ol {
      margin-left: 20px;
      padding-left: 15px;
      margin-bottom: 20px;
    }

    li:not(nav.toc li) { /* Применяем только к li вне TOC */
      margin-bottom: 15px;
      padding-left: 5px;
    }

    li p {
      margin-bottom: 5px;
    }

    li>ul,
    li>ol {
      margin-top: 10px;
      margin-bottom: 10px;
    }

    strong {
      color: #d9534f;
      font-weight: 500;
    }

    .note {
      background-color: var(--note-bg-color);
      border-left: 5px solid var(--note-border-color);
      padding: 15px 20px;
      margin: 25px 0;
      border-radius: 6px;
      box-shadow: 0 2px 5px var(--shadow-color);
    }

    .note p {
      margin-bottom: 10px;
    }

    .note p:last-child {
      margin-bottom: 0;
    }

    .note strong {
      font-weight: 700;
    }

    .note pre {
      margin-top: 15px;
      margin-bottom: 5px;
    }

    .theme-switcher {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 8px;
      background-color: var(--button-bg-color);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      cursor: pointer;
      z-index: 1000;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px var(--shadow-color);
      transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
    }

    .theme-switcher svg {
      width: 20px;
      height: 20px;
      fill: var(--icon-fill);
      transition: fill 0.3s;
    }

    .theme-switcher .icon-sun { display: none; }
    .theme-switcher .icon-moon { display: block; }
    body.dark-theme .theme-switcher .icon-sun { display: block; }
    body.dark-theme .theme-switcher .icon-moon { display: none; }

    /* Медиа-запрос для маленьких экранов */
    @media (max-width: 768px) {
      .content-wrapper {
        flex-direction: column; /* Возвращаем блочное расположение */
        gap: 0; /* Убираем отступ */
      }
      nav.toc {
        position: static; /* Убираем sticky на мобильных */
        width: auto;      /* Автоматическая ширина на мобильных */
        margin-bottom: 20px; /* Добавляем отступ снизу */
        max-height: none; /* Убираем ограничение по высоте на мобильных */
        overflow-y: visible; /* Убираем скролл на мобильных */
        align-self: auto; /* Сбрасываем align-self */
      }
      body {
        scroll-padding-top: 20px; /* Убираем увеличенный отступ на мобильных */
      }
    }

    nav.toc ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    nav.toc li {
      margin-bottom: 5px;
      /* Removed padding-left: 0; as details/summary handle structure */
    }

    /* Style for top-level list items OR items within an open details */
    nav.toc > ul > li > a,
    nav.toc details[open] > ul > li > a {
      text-decoration: none;
      color: var(--link-color);
      transition: color 0.2s;
      font-size: 0.85em;
      display: block;
      padding: 3px 0 3px 10px; /* Add padding for items without details */
    }
    nav.toc > ul > li > a:hover,
    nav.toc details[open] > ul > li > a:hover {
       text-decoration: underline;
       color: var(--heading-color);
    }

    /* Styling for <details> and <summary> */
    nav.toc details {
        margin-bottom: 5px; /* Consistent spacing */
    }

    nav.toc summary {
        list-style: none; /* Remove default triangle marker */
        cursor: pointer;
        position: relative;
        padding: 3px 0 3px 10px; /* Base padding */
        padding-left: 25px; /* Space for custom marker */
        outline: none; /* Remove focus outline */
        /* Apply link-like styling directly to summary text when it's not a link */
        font-size: 0.85em; 
        color: var(--link-color);
        /* Prevent text selection on click */
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }

    nav.toc summary::-webkit-details-marker { /* Hide marker in WebKit */
        display: none;
    }

    nav.toc summary::before { /* Custom marker */
        content: '▸'; /* Closed state marker */
        position: absolute;
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.8em;
        color: var(--text-color);
        transition: transform 0.2s ease-in-out;
    }

    nav.toc details[open] > summary::before {
        transform: translateY(-50%) rotate(90deg); /* Open state marker */
    }

    /* Link inside summary (if exists) */
    nav.toc summary a {
        text-decoration: none;
        color: inherit; /* Inherit color from summary */
        transition: color 0.2s;
        font-size: inherit; /* Inherit font size from summary */
        /* display: inline; /* Ensure it doesn't break layout */
    }

    nav.toc summary a:hover {
        text-decoration: underline;
        color: var(--heading-color);
    }

    /* Styling for the nested list inside <details> */
    nav.toc details > ul {
        list-style: none;
        padding-left: 25px; /* Indentation for sub-items */
        margin-top: 5px; /* Space between summary and list */
        margin-bottom: 5px;
    }

    nav.toc details > ul > li a {
        text-decoration: none;
        color: var(--link-color);
        transition: color 0.2s;
        font-size: 0.85em;
        display: block;
        padding: 3px 0;
    }

    nav.toc details > ul > li a:hover {
        text-decoration: underline;
        color: var(--heading-color);
    }

    /* GitHub link below TOC */
    .toc-footer {
        margin-top: 20px; /* Space above the divider */
        padding-top: 15px; /* Space below the divider */
        border-top: 1px solid var(--border-color); /* Divider line */
        text-align: center; /* Center the icons */
        /* padding-left: 10px; Removed as centering handles alignment */
    }

    .toc-footer a {
        display: inline-block; /* Allows setting dimensions */
        line-height: 0; /* Prevent extra space around SVG */
        margin: 0 5px; /* Add horizontal spacing between icons if more are added */
    }

    .toc-footer svg {
        width: 25px;
        height: 25px;
        fill: var(--text-color); /* Use text color for the icon */
        transition: fill 0.2s;
    }

    .toc-footer a:hover svg {
        fill: var(--link-color); /* Change color on hover */
    }

  </style>
</head>

<body>

  
  <button class="theme-switcher" id="theme-toggle" aria-label="Сменить тему">
    <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.64 5.64c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41l1.06 1.06c.39.39 1.02.39 1.41 0s.39-1.02 0-1.41L5.64 5.64zm12.73 12.73c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41l1.06 1.06c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41l-1.06-1.06zm1.06-10.61c.39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.02 0 1.41s1.02.39 1.41 0l1.06-1.06zm-12.73 12.73c.39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0l1.06-1.06z" /></svg>
    <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9c.83 0 1.62-.11 2.36-.31.4-.1.64-.51.54-.91s-.51-.64-.91-.54A7.01 7.01 0 0 1 12 19c-3.86 0-7-3.14-7-7s3.14-7 7-7c1.64 0 3.14.56 4.34 1.5C16.73 6.9 17 7.3 17 7.75c0 .69.79 1.04 1.34.66C19.44 7.48 20 6.28 20 5c0-1.1-.9-2-2-2h-.5c-1.14 0-2.2.37-3.09.99-.48.33-1.09.46-1.71.41C12.38 4.35 12 4.01 12 3.58V3z" /></svg>
  </button>

  
  <div class="content-wrapper">

    
    <nav class="toc">
      <ul>
        
        <li><a href="#intro">Введение</a></li>
        <li><a href="#how-it-works">Принцип работы</a></li>
        <li><a href="#features">Ключевые возможности</a></li>
        
        <li><a href="#what-is-backed-up">Что бэкапится?</a></li>
        
        <li><a href="#prerequisites-gcp">Предварительная настройка: Google Cloud</a></li>
        
        <li><a href="#first-auth">Первая авторизация: token.json</a></li>
        
        <li><a href="#quick-start-docker">Быстрый старт (Docker)</a></li>
        
        <li>
          <details>
            <summary>Настройка без Docker</summary> 
            <ul>
              <li><a href="#setup-script">Подготовка Скрипта</a></li> 
              
              <li><a href="#running-script">Запуск скрипта</a></li>
              <li><a href="#automation">Автоматизация (Cron)</a></li>
            </ul>
          </details>
        </li>
        
        <li>
          <details>
            <summary>Режимы работы (Флаги)</summary> 
            <ul>
              <li><a href="#mode-full-sync">Полная синхронизация</a></li>
              <li><a href="#mode-incremental">Инкрементальный режим</a></li>
              <li><a href="#mode-dry-run">Тестовый режим</a></li>
              <li><a href="#mode-s3">Выгрузка в S3</a></li>
              <li><a href="#mode-no-archive">Отключение архивации</a></li>
            </ul>
          </details>
        </li>
        
        <li><a href="#configuration">Конфигурация (.env)</a></li>
        
        <li><a href="#project-structure">Структура проекта</a></li>
        
        <li><a href="#state-management">Управление состоянием</a></li>
        
        <li><a href="#api-limits">Ограничения API</a></li>
        
        <li><a href="#troubleshooting">Решение Проблем</a></li>
      </ul>
      
      <div class="toc-footer">
          <a href="https://github.com/eblet/driveup" target="_blank" rel="noopener noreferrer" title="GitHub Repository">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" role="img" aria-label="GitHub logo">
                  <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
              </svg>
          </a>
      </div>

    </nav>

    
    <main class="main-content">

      
      <h1 id="intro">DRIVEUP: Бэкапы Google Drive <span style="font-size: 0.7em; vertical-align: middle;">v.1.1.0 🎈</span></h1>

      <p>Этот скрипт предназначен для автоматического резервного копирования содержимого "Моего диска" и всех доступных "Общих дисков" пользователя из Google Drive.</p>
      <p>Он идеально подходит для создания регулярных бэкапов на сервер или локально с использованием выделенной учетной записи Google ("бэкапера").</p>

      <h2 id="how-it-works">Принцип работы: Эффективность Changes API</h2>
      <p>Ключевая особенность скрипта — использование механизма <a href="https://developers.google.com/drive/api/guides/manage-changes" target="_blank">Google Drive Changes API</a> (<code>changes.list</code>). <br> Это позволяет отказаться от полного сканирования всех файлов на Диске при каждом запуске.</p>
      <p>Как это работает:</p>
      <ol>
          <li><strong>Первый запуск (или если токен устарел):</strong> Скрипт выполняет <strong>полную синхронизацию</strong> для выбранного диска (Мой диск / Общий диск). <br> Он скачивает все файлы и папки, строит локальную структуру и сохраняет "карту состояния" (какой файл где лежит локально). <br> В конце этого процесса Google Drive API выдает специальный <strong>"токен изменений" (Start Page Token)</strong>. Скрипт сохраняет этот токен.</li>
          <li><strong>Последующие запуски:</strong> Скрипт отправляет сохраненный токен в Google Drive Changes API. В ответ API присылает <strong>только список изменений</strong>, произошедших на Диске <i>с момента получения этого токена</i>. <br> Этот список содержит информацию о:
              <ul>
                  <li>Новых файлах/папках</li>
                  <li>Измененных файлах (новая версия контента)</li>
                  <li>Переименованных или перемещенных файлах/папках</li>
                  <li>Удаленных файлах/папках</li>
              </ul>
          </li>
          <li><strong>Обработка изменений:</strong> Скрипт проходит по списку изменений и соответствующим образом обновляет локальный бэкап: скачивает новые/измененные файлы, создает/перемещает/переименовывает папки и файлы, удаляет удаленное.</li>
          <li><strong>Новый токен:</strong> После обработки всех изменений API предоставляет новый токен, который скрипт снова сохраняет для следующего запуска.</li>
      </ol>
      <p><strong>Преимущества:</strong></p>
      <ul>
          <li><strong>Скорость:</strong> Обработка только изменений происходит значительно быстрее полного сканирования, особенно на больших дисках с тысячами файлов.</li>
          <li><strong>Эффективность:</strong> Снижается нагрузка на сеть и API Google Drive.</li>
          <li><strong>Точность:</strong> Корректно отслеживаются перемещения и удаления, что сложно сделать при простом сравнении списков файлов.</li>
      </ul>
      <div class="note">
          <p><strong>Когда выполняется полная синхронизация?</strong></p>
          <p>Полная синхронизация (которая может быть долгой) выполняется только в следующих случаях:</p>
          <ul>
              <li>Самый первый запуск скрипта для конкретного диска (Мой диск или Общий диск).</li>
              <li>Если файл с токеном изменений (<code>start_token.txt</code>) был удален вручную.</li>
              <li>Если токен изменений устарел (например, прошло слишком много времени или изменений с последнего запуска, и Google API не может предоставить дельту). Скрипт обнаружит это автоматически (ошибка "pageToken not found") и запустит полную синхронизацию на следующем запуске.</li>
          </ul>
      </div>

      <h2 id="features">Ключевые возможности</h2>
      <ul>
        <li><strong>Эффективный инкрементальный бэкап:</strong> Использует <strong>Google Drive Changes API</strong> (подробнее см. <a href="#how-it-works">выше</a>).</li>
        <li><strong>Отслеживание удалений и перемещений:</strong> Корректно обрабатывает изменения структуры на Google Drive.</li>
        <li><strong>Поддержка Общих дисков:</strong> Копирует "Мой диск" и все доступные "Общие диски".</li>
        <li><strong>Сохранение структуры:</strong> Воссоздает структуру папок локально.</li>
        <li><strong>Конвертация форматов Google:</strong> Docs &rarr; <code>.docx</code>, Sheets &rarr; <code>.xlsx</code>, Presentations &rarr; <code>.pptx</code>, Drawings &rarr; <code>.png</code>.</li>
        <li><strong>Экспорт формул Google Sheets:</strong> Дополнительно создается <code>.csv</code> с формулами для каждой таблицы.</li>
        <li><strong>Подготовка к миграции:</strong> Экспортированные файлы можно загрузить на другой аккаунт.</li>
        <li><strong>Опциональная выгрузка в Amazon S3:</strong> Автоматическая загрузка скачанных файлов в S3 бакет.</li>
        <li><strong>Автоматическая авторизация:</strong> Использует OAuth с refresh-токеном.</li>
        <li><strong>Тестовый режим (Dry Run):</strong> Проверка работы на небольшой выборке.</li>
        <li><strong>Конфигурация через <code>.env</code>:</strong> Гибкая настройка.</li>
        <li><strong>Логирование:</strong> Подробный лог операций.</li>
        <li><strong>Деплой в Docker:</strong> Простой запуск в контейнере.</li>
      </ul>

      
      <h2 id="what-is-backed-up">Что именно бэкапится?</h2>
      <p>Скрипт выполняет резервное копирование данных от имени <strong>пользователя, чьи учетные данные (<code>credentials.json</code>, <code>token.json</code>) используются для запуска</strong>. Назовем его условно "бэкапер". Бэкапятся следующие данные этого пользователя:</p>
      <ul>
        <li>
          <p><strong>"Мой диск" (My Drive) бэкапера:</strong></p>
          <p>Полностью копируется содержимое <strong>собственного</strong> "Моего диска" бэкапера, включая все файлы и папки, которые там находятся. Сюда также входят <strong>ярлыки</strong> на файлы/папки, которые бэкапер добавил в свой "Мой диск".</p>
        </li>
        <li>
          <p><strong>"Общие диски" (Shared Drives / Team Drives):</strong></p>
          <p>Копируется содержимое <strong>всех</strong> "Общих дисков", <strong>участником которых является бэкапер</strong> (требуются как минимум права на чтение). Скрипт автоматически обнаруживает такие Общие диски. Каждый Общий диск сохраняется в свою отдельную подпапку внутри основной папки бэкапа.</p>
        </li>
      </ul>
      <div class="note">
        <p><strong>Как забэкапить файл/папку, которой с вами поделились из "Моего диска" другого пользователя?</strong></p>
        <p>Скрипт <strong>не ищет</strong> и <strong>не бэкапит</strong> автоматически отдельные файлы или папки, к которым бэкаперу просто предоставили доступ (расшарили) из <strong>"Моих дисков" других пользователей</strong> (т.е. те, что появляются в разделе "Доступные мне").</p>
        <p><strong>Решение:</strong></p>
        <ol>
          <li>Попросите владельца файла/папки (или пользователя с правами редактора) явно <strong>добавить аккаунт бэкапера в список доступа</strong> к этому файлу/папке.</li>
          <li><strong>ВАЖНО:</strong> Владелец должен убедиться, что в расширенных настройках доступа (<svg viewBox="0 0 16 16" fill="currentColor" style="width:1em; height:1em; vertical-align: text-bottom;"><path fill-rule="evenodd" d="M8.84 0.018a6.932 6.932 0 0 1 2.601.444l.27.108a.5.5 0 0 1 .289.648l-.073.182a.5.5 0 0 1-.648.288l-.27-.108a5.932 5.932 0 0 0-2.22-.374V1.5c0 .276-.224.5-.5.5S7.5 1.776 7.5 1.5V0.5c0-.276.224-.5.5-.5s.5.224.5.5v-.482ZM12.05 1.95a6.933 6.933 0 0 1 1.981 1.98l.108.27a.5.5 0 0 1-.288.648l-.182.073a.5.5 0 0 1-.648-.289l-.108-.27a5.932 5.932 0 0 0-1.69-.69l.181-.073a.5.5 0 0 1 .289-.648l-.108-.27Zm-8.1 0-.108.27a.5.5 0 0 1-.288.648l-.182.073a.5.5 0 0 1-.648-.288l-.108-.27a5.932 5.932 0 0 0-1.69 1.69l-.073.182a.5.5 0 0 1-.648.289L0 3.95a.5.5 0 0 1-.288-.648l.108-.27A6.932 6.932 0 0 1 1.95 1.95l.27-.108a.5.5 0 0 1 .648.289l.073.182a.5.5 0 0 1-.288.648l-.27.108Zm9.168 9.168.27.108a.5.5 0 0 1 .288.648l-.073.182a.5.5 0 0 1-.648.288l-.27-.108a5.932 5.932 0 0 0-1.69 1.69l-.182.073a.5.5 0 0 1-.648.289l-.27-.108a6.932 6.932 0 0 1-1.98-1.98l-.108-.27a.5.5 0 0 1 .288-.648l.182-.073a.5.5 0 0 1 .648.289l.108.27a5.932 5.932 0 0 0 1.69 1.69Zm-9.168 0a5.932 5.932 0 0 0 1.69-1.69l.108-.27a.5.5 0 0 1 .648-.289l.182.073a.5.5 0 0 1 .288.648l-.108.27a6.932 6.932 0 0 1-1.98 1.98l-.27.108a.5.5 0 0 1-.648-.288l-.073-.182a.5.5 0 0 1 .288-.648l.27-.108Zm-1.5-4.618V8.5c0 .276.224.5.5.5s.5-.224.5-.5V7.5c0-.276-.224-.5-.5-.5s-.5.224-.5.5Zm13 0V8.5c0 .276-.224.5-.5.5s-.5-.224-.5-.5V7.5c0-.276.224-.5.5-.5s.5.224.5.5Zm-6.5 8v-1c0-.276.224-.5.5-.5s.5.224.5.5v1c0 .276-.224-.5-.5.5s-.5-.224-.5-.5Zm0-13.982V1.5c0-.276-.224-.5-.5-.5S7.5 1.224 7.5 1.5v.518a6.932 6.932 0 0 1-2.601.444l-.27.108a.5.5 0 0 1-.288.648l.073.182a.5.5 0 0 1 .648.288l.27-.108a5.932 5.932 0 0 0 2.22-.374V3c0 .276.224.5.5.5s.5-.224.5-.5V2.518a5.932 5.932 0 0 0 2.22.374l.27.108a.5.5 0 0 1 .648-.288l.073-.182a.5.5 0 0 1-.288-.648l-.27-.108A6.932 6.932 0 0 1 8.5.018ZM8 4a4 4 0 1 1 0 8 4 4 0 0 1 0-8Zm0 1a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z" clip-rule="evenodd"></path></svg>) <strong>разрешено скачивание для читателей и комментаторов</strong>. Без этого разрешения бэкапер получит ошибку 403 Forbidden при попытке скачать файл.</li>
          <li><strong>На аккаунте бэкапера</strong> найдите этот расшаренный элемент (например, в "Доступные мне") и <strong>добавьте ярлык на него в свой "Мой диск"</strong> (Правый клик &rarr; "Добавить ярлык на Диск" &rarr; "Мой диск").</li>
        </ol>
        <p>Теперь, когда скрипт будет сканировать "Мой диск" бэкапера, он обнаружит этот ярлык и сможет забэкапить оригинальный файл/папку (при наличии прав на скачивание).</p>
        <p><strong>Альтернатива для совместной работы:</strong> Использовать "Общие диски", так как они бэкапятся автоматически, если бэкапер является их участником.</p>
      </div>
      <div class="note">
        <p><strong>Обработка файлов с Общих дисков при синхронизации "Моего диска":</strong></p>
        <p>Когда скрипт синхронизирует "Мой диск", он может встретить файлы или папки, которые на самом деле хранятся на каком-либо Общем диске (например, если вы добавили ярлык или Google некорректно отображает их принадлежность).</p>
        <p>Скрипт проверяет, является ли Общий диск, которому принадлежит файл, одним из тех, что он обрабатывает отдельно:</p>
        <ul>
            <li>Если да (т.е. бэкапер - участник этого Общего диска), то файл/папка **пропускается** при синхронизации "Моего диска", чтобы избежать дублирования. Он будет забэкаплен при обработке самого Общего диска.</li>
            <li>Если нет (т.е. бэкапер **не** является участником Общего диска или Общий диск вообще не найден), скрипт считает такой файл/папку "осиротевшим" из другого хранилища. Чтобы не потерять его, скрипт поместит его в специальную папку внутри вашего бэкапа "Моего диска". Имя этой папки задается переменной <code>SHARED_FILES_DIR_NAME</code> в файле <code>.env</code> (по умолчанию "Shared With Me"). Внутри этой папки будут созданы подпапки с ID Общего диска, откуда пришел файл. Эти файлы скачиваются, но <strong>не добавляются в основное состояние</strong> "Моего диска" и не влияют на его инкрементальную синхронизацию.</li>
        </ul>
        <p>Это гарантирует, что данные не будут потеряны, даже если они хранятся в неожиданном месте или доступ к Общему диску был утрачен.</p>
      </div>

      
      <h2 id="prerequisites-gcp">Предварительная настройка: Google Cloud</h2>
      <p>Для работы скрипта <strong>необходимо</strong> получить учетные данные API Google Drive. <br> Этот шаг выполняется один раз, независимо от способа запуска (Docker или без).</p>
      <ol>
        <li>Перейдите в <a href="https://console.cloud.google.com/" target="_blank">Google Cloud Console</a> и войдите в аккаунт Google, который будет использоваться для бэкапа (аккаунт бэкапера).</li>
        <li>Создайте новый проект или выберите существующий.</li>
        <li>Включите необходимые API:
          <ul>
            <li>Перейдите в "API и сервисы" &rarr; "Библиотека".</li>
            <li>Найдите и включите <strong>Google Drive API</strong>.</li>
            <li>Найдите и включите <strong>Google Sheets API</strong> (требуется для экспорта формул из таблиц).</li>
          </ul>
        </li>
        <li>Настройте Экран согласия OAuth:
          <ul>
            <li>Перейдите в "API и сервисы" &rarr; "Экран согласия OAuth".</li>
            <li>Выберите тип пользователя: "Внешние" (External) для стандартных аккаунтов @gmail.com или если пользователи вне вашей Google Workspace организации будут авторизовываться. <br> "Внутренние" (Internal) возможно только для Google Workspace и ограничивает авторизацию пользователями вашей организации. <br> <strong>Рекомендуется "Внешние"</strong> для совместимости.</li>
            <li>Заполните название приложения (например, "DRIVEUP Backup"), email поддержки (ваш email) и контакты разработчика (ваш email).</li>
            <li>Шаг "Области" (Scopes) можно пропустить (нажать "Сохранить и продолжить"), так как скрипт сам запросит нужные области.</li>
            <li>Если вы выбрали тип "Внешние" и статус приложения "Тестирование" (Testing), добавьте email вашего бэкапера в разделе "Тестовые пользователи".</li>
            <li>Нажмите "Вернуться на панель управления".</li>
          </ul>
        </li>
        <li><strong>ВАЖНО: Опубликуйте приложение!</strong>
          <ul>
            <li>На странице "Экран согласия OAuth" найдите "Статус публикации".</li>
            <li>Если статус "Тестирование", нажмите кнопку <strong>"Опубликовать приложение"</strong> (Publish App) и подтвердите. Статус должен измениться на "Опубликовано" (In production).</li>
            <li><b>Это критически важно, чтобы предотвратить аннулирование токена обновления (refresh token) каждые 7 дней.</b> Если токен аннулируется, вам придется заново проходить авторизацию (см. <a href="#first-auth">Шаг 2: Первая авторизация</a> ниже).</li>
          </ul>
        </li>
        <li>Создайте Учетные данные клиента OAuth:
          <ul>
            <li>Перейдите в "API и сервисы" &rarr; "Учетные данные".</li>
            <li>Нажмите "+ Создать учетные данные" &rarr; "Идентификатор клиента OAuth".</li>
            <li>Тип приложения: <strong>Настольное приложение (Desktop app)</strong>.</li>
            <li>Введите имя (например, "Driveup Credentials").</li>
            <li>Нажмите "Создать".</li>
          </ul>
        </li>
        <li>Скачайте JSON-файл:
          <ul>
            <li>В появившемся окне нажмите <strong>"Скачать JSON"</strong>.</li>
            <li>Сохраните файл и <strong>переименуйте его в <code>credentials.json</code></strong> (или имя, указанное в переменной <code>CREDENTIALS_FILE</code> в <code>.env</code>).</li>
            <li>Поместите этот файл в корневую директорию проекта со скриптом <code>main.py</code>.</li>
          </ul>
        </li>
      </ol>
      <div class="note">
        <p><strong>Безопасность:</strong> Файл <code>credentials.json</code> содержит чувствительные данные.</p>
        <p><strong>НЕ ДОБАВЛЯЙТЕ ЕГО В GIT</strong></p>
      </div>

      
      <h3 id="first-auth">Первая Авторизация // Получение token.json</h3>
      <p>Этот шаг выполняется <strong>один раз</strong> после получения <code>credentials.json</code> и <strong>необходим как для Docker, так и для ручного запуска</strong>, чтобы получить файл <code>token.json</code>.</p>
      <p>Для автоматической работы скрипту нужен файл <code>token.json</code>, содержащий токен обновления (refresh token).</p>
      <ol>
        <li>Убедитесь, что <code>credentials.json</code> (из <a href="#prerequisites-gcp">Предварительной настройки</a>) находится в папке со скриптом.</li>
        <li>Запустите скрипт один раз <strong>на машине с графическим интерфейсом и браузером</strong> (это может быть ваш локальный компьютер, не обязательно сервер, где будет работать бэкап):
          <pre><code class="language-bash"># Убедитесь, что виртуальное окружение активно (если используете)
# (source venv/bin/activate или аналог для Windows)

# Запустите скрипт с флагом --incremental (или --full)
# Это необходимо, так как скрипт требует указания режима.
# Если token.json отсутствует, скрипт запустит процесс авторизации.
python main.py --incremental</code></pre>
        </li>
        <li>Скрипт попытается открыть браузер и отобразит URL для авторизации. Перейдите по этому URL.</li>
        <li>Войдите в аккаунт Google (аккаунт бэкапера), который вы настраивали на этапе <a href="#prerequisites-gcp">Предварительной настройки</a>.</li>
        <li>Предоставьте скрипту разрешения на доступ к Google Drive и Google Sheets (если запросит).</li>
        <li>После успешной авторизации скрипт создаст файл <code>token.json</code> (или имя, указанное в <code>TOKEN_FILE</code> в <code>.env</code>) в той же директории.</li>
        <li>Теперь скрипт может начать первый бэкап. Вы можете прервать его (Ctrl+C), если вам нужен был только файл <code>token.json</code>.</li>
        <li><strong>Скопируйте полученный <code>token.json</code> на сервер</strong> (если бэкап будет работать там) или в папку проекта для Docker, в ту же папку, где лежит <code>main.py</code> и <code>credentials.json</code>.</li>
      </ol>
      <div class="note">
        <p><strong>Безопасность:</strong> Файл <code>token.json</code> также содержит чувствительные данные. <br> <strong>НЕ ДОБАВЛЯЙТЕ ЕГО В GIT</strong></p>
        <p><strong>Почему нужна машина с браузером?</strong> <br> Процесс OAuth 2.0 для настольных приложений требует взаимодействия пользователя через браузер для предоставления разрешений.</p>
      </div>

      
      <h2 id="quick-start-docker">Быстрый старт (Docker)</h2>
      <p>Использование Docker и Docker Compose — <strong>рекомендуемый и самый простой способ</strong> запуска скрипта, так как он изолирует зависимости и упрощает развертывание.</p>
      <ol>
        <li><strong>Предварительные требования:</strong>
            <ul>
                <li>Установленные <a href="https://docs.docker.com/engine/install/" target="_blank">Docker</a> и <a href="https://docs.docker.com/compose/install/" target="_blank">Docker Compose</a>.</li>
                <li>Файл <code>credentials.json</code>, полученный на шаге <a href="#prerequisites-gcp">Предварительная настройка: Google Cloud</a>. Поместите его в корневую папку проекта.</li>
                <li>Файл <code>token.json</code>, полученный на шаге <a href="#first-auth">Первая авторизация</a> (см. выше). Поместите его в корневую папку проекта.</li>
            </ul>
        </li>
        <li><strong>Файлы проекта:</strong> Убедитесь, что в директории вашего проекта находятся как минимум:
          <ul>
            <li><code>Dockerfile</code></li>
            <li><code>docker-compose.yml</code></li>
            <li><code>main.py</code></li>
            <li><code>src/</code> (папка с исходным кодом)</li>
            <li><code>requirements.txt</code></li>
            <li><code>.env</code> (создайте его, скопировав из примера <a href="#configuration">ниже</a>, или настройте по своему усмотрению)</li>
            <li><code>credentials.json</code></li>
            <li><code>token.json</code></li>
          </ul>
        </li>
        <li><strong>Запуск бэкапа:</strong>
          <p>Используйте команду <code>docker compose run</code>. <strong>Теперь необходимо явно указать режим синхронизации: <code>--full</code> или <code>--incremental</code>.</strong></p>
          <pre><code class="language-bash"># Убедитесь, что вы находитесь в директории проекта

# Запустить ПРИНУДИТЕЛЬНУЮ ПОЛНУЮ СИНХРОНИЗАЦИЮ
# Игнорирует и удаляет предыдущее состояние (токены, карты)
# Ключ --rm удалит контейнер после завершения
docker compose run --rm driveup python main.py --full

# Запустить РЕКОМЕНДУЕМЫЙ ИНКРЕМЕНТАЛЬНЫЙ БЭКАП
# Использует предыдущее состояние, если оно есть, для скачивания только изменений
docker compose run --rm driveup python main.py --incremental

# Запустить тестовый режим (dry-run) для полной синхронизации
docker compose run --rm driveup python main.py --full --dry-run

# Запустить тестовый режим (dry-run) для инкрементального бэкапа
docker compose run --rm driveup python main.py --incremental --dry-run

# Запустить с выгрузкой в S3 (инкрементальный режим)
docker compose run --rm driveup python main.py --incremental --s3-bucket my-s3-backups --s3-prefix gd_sync/</code></pre>
          <p>Docker Compose автоматически:</p>
          <ul>
            <li>Соберет образ `driveup` при первом запуске (или если `Dockerfile` изменился).</li>
            <li>Подключит необходимые файлы (<code>credentials.json</code>, <code>token.json</code>, <code>.env</code>) и папки (<code>driveup_backup</code>, <code>driveup_state</code>) с хост-машины внутрь контейнера, как указано в <code>docker-compose.yml</code>.</li>
            <li>Запустит команду <code>python main.py</code> с переданными вами флагами (<code>--full</code> или <code>--incremental</code> и другие).</li>
            <li>Выведет логи выполнения прямо в вашу консоль.</li>
          </ul>
        </li>
        <li><strong>Автоматизация (Cron + Docker):</strong> Для регулярного запуска настройте `cron` на хост-машине, как описано в разделе <a href="#automation">Автоматизация запуска (Cron)</a>, используя команду `docker compose run` <strong>с флагом <code>--incremental</code></strong>.</li>
      </ol>
      <div class="note">
          <p><strong>Первый запуск `docker compose run` может занять время</strong>, пока скачивается базовый образ Python и устанавливаются зависимости.</p>
          <p>Убедитесь, что файлы <code>.env</code>, <code>credentials.json</code>, <code>token.json</code> существуют <strong>до</strong> запуска, иначе Docker не сможет их смонтировать.</p>
          <p>Docker создаст папки для бэкапа (<code>driveup_backup</code> по умолчанию) и состояния (<code>driveup_state</code> по умолчанию) на хост-машине, если они не существуют.</p>
      </div>

      
      <h2 id="full-setup">Настройка без Docker</h2>
      <p>Если вы не хотите использовать Docker, следуйте этим шагам после выполнения <a href="#prerequisites-gcp">Предварительной настройки Google Cloud</a> и <a href="#first-auth">Первой авторизации</a>.</p>

      <h3 id="setup-script">Шаг 1: Подготовка Скрипта и Зависимостей</h3>
      <ol>
        <li>Скопируйте файлы скрипта (<code>main.py</code>, папка <code>src/</code>, <code>requirements.txt</code>), создайте файл <code>.env</code> (см. <a href="#configuration">Конфигурация</a>) и поместите <code>credentials.json</code> и <code>token.json</code> в одну директорию на машине, где будет запускаться бэкап.</li>
        <li>Создайте и активируйте виртуальное окружение Python (рекомендуется):
          <pre><code class="language-bash"># Убедитесь, что вы находитесь в директории проекта

# Создать виртуальное окружение (например, venv)
python3 -m venv venv
</code></pre>
        </li>
        <li>Установите зависимости (в активированном окружении):
          <pre><code class="language-bash">pip install -r requirements.txt

# Если планируете использовать выгрузку в S3, установите также:
pip install boto3</code></pre>
          <p>(Если используете Poetry, выполните <code>poetry install --no-dev</code>).</p>
        </li>
      </ol>

      <h3 id="running-script">Шаг 2: Запуск Скрипта</h3>
      <p>Теперь, когда у вас есть <code>credentials.json</code>, <code>token.json</code> и установлены зависимости, вы можете запускать скрипт. <strong>Необходимо явно указать режим синхронизации: <code>--full</code> или <code>--incremental</code>.</strong></p>
      <ul>
        <li>
          <p><strong>Запуск вручную:</strong></p>
          <pre><code class="language-bash"># Убедитесь, что вы находитесь в директории проекта

# Активировать окружение
source venv/bin/activate

# Запуск ПОЛНОЙ синхронизации
python main.py --full

# Запуск ИНКРЕМЕНТАЛЬНОЙ синхронизации
python main.py --incremental</code></pre>
        </li>
        <li>
          <p><strong>Первый запуск vs Последующие:</strong></p>
          <p>Запуск с флагом <code>--full</code> всегда выполнит <strong>полную синхронизацию</strong>, удаляя предыдущее состояние.</p>
          <p>Запуск с флагом <code>--incremental</code>:</p>
          <ul>
              <li>Если файлы состояния для диска существуют (<code>start_token.txt</code>, <code>drive_state.json</code>), будет выполнен инкрементальный бэкап.</li>
              <li>Если файлы состояния отсутствуют (или токен устарел), будет выполнена полная синхронизация для этого диска, а затем сохранено состояние для будущих инкрементальных запусков.</li>
          </ul>
        </li>
        <li>
          <p><strong>Куда сохраняются файлы:</strong></p>
          <p>Скрипт создаст две основные папки (если их нет) в директории, откуда он запущен (пути можно изменить в <code>.env</code>):</p>
          <ul>
              <li><code>driveup_backup</code> (<code>BASE_DOWNLOAD_DIR</code>): Сюда скачиваются сами файлы и папки с Google Drive. Структура внутри будет отражать структуру вашего Диска (с подпапками для My Drive и каждого Shared Drive).</li>
              <li><code>driveup_state</code> (<code>STATE_DIR</code>): Здесь хранятся служебные файлы состояния (<code>drive_state.json</code>, <code>start_token.txt</code>) для каждого диска в своей подпапке. <strong>Не удаляйте эту папку</strong>, если хотите, чтобы инкрементальные бэкапы работали.</li>
          </ul>
        </li>
      </ul>

      <h3 id="automation">Автоматизация запуска (Cron)</h3>
      <p>Для регулярного автоматического запуска бэкапа на Linux/macOS сервере можно использовать <code>cron</code>.</p>
      <ol>
          <li>Убедитесь, что все файлы (<code>main.py</code>, <code>.env</code>, <code>requirements.txt</code>, <code>credentials.json</code>, <code>token.json</code>) находятся на сервере, настроено виртуальное окружение и установлены зависимости.</li>
          <li>Установите безопасные права на файлы учетных данных:
              <pre><code class="language-bash"># В директории проекта:
chmod 600 credentials.json token.json</code></pre>
          </li>
          <li>Откройте редактор crontab: <code>crontab -e</code></li>
          <li>Добавьте строку для запуска. Пример для запуска <strong>каждый день в 3:05 утра</strong>:</li>
      </ol>
      <p><strong>Вариант 1: Запуск без Docker</strong></p>
      <pre><code class="language-cron"># Запуск бэкапа driveup (без Docker) каждый день в 3:05 ИНКРЕМЕНТАЛЬНЫЙ
# ... (описание путей) ...
5 3 * * * /usr/bin/flock -n /tmp/driveup_backup.lock venv/bin/python3 main.py --incremental >> logs/backup.log 2>&1</code></pre>

      <p><strong>Вариант 2: Запуск через Docker Compose (рекомендуется)</strong></p>
      <pre><code class="language-cron"># Запуск бэкапа driveup (Docker) каждый день в 3:05 ИНКРЕМЕНТАЛЬНЫЙ
# ... (описание путей) ...
5 3 * * * /usr/bin/flock -n /tmp/driveup_backup.lock docker compose run --rm driveup python main.py --incremental >> logs/backup_docker.log 2>&1</code></pre>

      <p><strong>Пояснения к строкам Cron:</strong></p>
      <ul>
          <li><code>5 3 * * *</code>: Время запуска (минуты, часы, день месяца, месяц, день недели). В данном случае - 3:05 ночи ежедневно.</li>
          <li><strong>Важно:</strong> Команда `cron` должна выполняться с <strong>корневой директорией проекта</strong> в качестве текущей рабочей директории. Это можно сделать либо с помощью `cd /полный/путь/к/проекту && ...` в строке cron, либо запуская команду из скрипта-обертки, который сначала переходит в нужную директорию.</li>
          <li><code>/usr/bin/flock -n /tmp/driveup_backup.lock</code>: (Опционально, но рекомендуется) Предотвращает одновременный запуск нескольких копий скрипта, если предыдущий запуск еще не завершился. Убедитесь, что путь к <code>flock</code> (<code>/usr/bin/flock</code>) верен для вашей системы (<code>which flock</code>). Путь к lock-файлу (<code>/tmp/driveup_backup.lock</code>) можно изменить.</li>
          <li><code>venv/bin/python3 main.py --incremental</code> (Вариант 1): Запуск инкрементального бэкапа.</li>
          <li><code>docker compose run --rm driveup python main.py --incremental</code> (Вариант 2): Запуск инкрементального бэкапа через Docker.</li>
          <li><code>>> logs/backup....log 2>&1</code>: Перенаправляет стандартный вывод и ошибки в лог-файл внутри папки <code>logs</code> в директории проекта. Создайте папку <code>logs</code> вручную (<code>mkdir logs</code>).</li>
      </ul>
      <p><em>Примечание для Windows:</em> Используйте встроенный Планировщик Задач (Task Scheduler) для настройки аналогичного запуска по расписанию, указав соответствующую команду (<code>python main.py --incremental</code> или <code>docker compose run --rm driveup python main.py --incremental</code>) и настроив рабочую директорию.</p>

      
      <h2 id="operational-modes">Режимы работы (Флаги)</h2>
      <p>Скрипт запускается с <strong>обязательным</strong> указанием одного из режимов синхронизации (<code>--full</code> или <code>--incremental</code>) и опциональными дополнительными флагами.</p>

      <h3 id="mode-full-sync">--full (Полная синхронизация)</h3>
      <p><strong>Обязательный флаг для полной синхронизации.</strong></p>
      <p>В этом режиме скрипт <strong>принудительно выполняет полную синхронизацию</strong> для каждого диска (Мой диск, Общие диски). Перед началом синхронизации он <strong>удаляет все существующие файлы состояния</strong> (<code>start_token.txt</code>, <code>drive_state.json</code>) для этого диска.</p>
      <p><strong>Когда использовать:</strong></p>
      <ul>
          <li>При самом первом запуске для первоначального скачивания.</li>
          <li>Если вы хотите гарантированно получить полностью свежую копию данных с Google Drive, игнорируя предыдущее состояние бэкапа.</li>
          <li>Если вы подозреваете, что файлы состояния повреждены и хотите начать с чистого листа.</li>
      </ul>
      <p><strong>Внимание:</strong> Этот режим может быть неэффективен для регулярных бэкапов, так как каждый раз скачивает все файлы заново, независимо от изменений. <br> Для регулярных бэкапов используйте <a href="#mode-incremental">инкрементальный режим (`--incremental`)</a>.</p>

      <h4>Запуск без Docker:</h4>
      <pre><code class="language-bash"># Выполняет принудительную полную синхронизацию
python main.py --full</code></pre>

      <h4>Запуск с Docker:</h4>
      <pre><code class="language-bash"># Выполняет принудительную полную синхронизацию
docker compose run --rm driveup python main.py --full</code></pre>
      <p>В этом режиме скрипт:</p>
      <ul>
        <li><strong>Удаляет</strong> предыдущие файлы состояния (токен изменений, карта ID-путь) для каждого диска.</li>
        <li>Выполняет <strong>полную синхронизацию</strong>: скачивает все файлы и папки с нуля.</li>
        <li>Конвертирует форматы Google Workspace.</li>
        <li>Создает новые файлы состояния (токен изменений, карта ID-путь).</li>
      </ul>

      <hr style="margin: 30px 0; border: 0; border-top: 1px solid var(--border-color);">

      <h3 id="mode-incremental">--incremental (Инкрементальный режим)</h3>
      <p><strong>Обязательный флаг для инкрементальной синхронизации.</strong> Рекомендуемый режим для регулярных бэкапов.</p>
      <p>В этом режиме скрипт проверяет наличие токена изменений (из файла <code>START_TOKEN_FILENAME</code> в папке состояния) для каждого диска. Если токен есть, запрашивает у Google Drive API <strong>только список изменений</strong> (новые, измененные, перемещенные, удаленные файлы/папки) с момента последнего запуска. Если токена нет (например, первый запуск с флагом <code>--incremental</code>, или токен устарел и был удален), скрипт выполнит <strong>полную синхронизацию</strong> для данного диска, но <strong>сохранит</strong> новый токен и состояние для последующих инкрементальных запусков. Обновляет локальный бэкап в соответствии с полученными изменениями: скачивает новые/измененные файлы, обновляет структуру папок локально, удаляет локальные копии удаленных на Диске файлов. Конвертирует форматы Google Workspace для новых/измененных файлов. Обновляет файлы состояния (токен изменений, карта ID-путь).</p>
      <p><strong>Преимущества:</strong> Значительно быстрее и эффективнее полной синхронизации, так как обрабатываются только изменения.</p>

      <h4>Запуск без Docker:</h4>
      <pre><code class="language-bash"># Выполняет инкрементальный бэкап
python main.py --incremental</code></pre>

      <h4>Запуск с Docker:</h4>
      <pre><code class="language-bash"># Выполняет инкрементальный бэкап
docker compose run --rm driveup python main.py --incremental</code></pre>

      <hr style="margin: 30px 0; border: 0; border-top: 1px solid var(--border-color);">

      <h3 id="mode-dry-run">--dry-run (Тестовый режим)</h3>
      <p>Флаг <code>--dry-run</code> можно использовать <strong>совместно</strong> с <code>--full</code> или <code>--incremental</code> для проверки без реальных изменений.</p>
      <h4>Запуск без Docker:</h4>
      <pre><code class="language-bash"># Тестовый запуск полной синхронизации
python main.py --full --dry-run

# Тестовый запуск инкрементальной синхронизации
python main.py --incremental --dry-run</code></pre>
      <h4>Запуск с Docker:</h4>
      <pre><code class="language-bash"># Тестовый запуск полной синхронизации
docker compose run --rm driveup python main.py --full --dry-run

# Тестовый запуск инкрементальной синхронизации
docker compose run --rm driveup python main.py --incremental --dry-run</code></pre>
      <p>В этом режиме скрипт:</p>
      <ul>
        <li>При полной синхронизации обрабатывает только <strong>небольшую случайную выборку</strong> файлов и папок (количество задается <code>DRY_RUN_SAMPLE_SIZE</code>, приоритет у папок и файлов меньше <code>DRY_RUN_MAX_FILE_SIZE_MB</code>).</li>
        <li>При инкрементальной синхронизации обрабатывает все изменения, но без скачивания больших файлов (ограничение <code>DRY_RUN_MAX_FILE_SIZE_MB</code>).</li>
        <li>Логирует операции создания/обновления/удаления, но <strong>не выполняет</strong> их на самом деле на локальной файловой системе.</li>
        <li>Сохраняет карту состояния в отдельный файл (имя задается <code>STATE_MAP_DRY_RUN_FILENAME</code> в <code>.env</code>), не затрагивая основной файл состояния.</li>
        <li><strong>Не сохраняет</strong> токен изменений (<code>START_TOKEN_FILENAME</code>).</li>
      </ul>
      <p><strong>Известная проблема (Dry Run + Full Sync):</strong> При выполнении <strong>полной синхронизации</strong> в режиме <code>--dry-run</code> (например, при первом запуске для диска), итоговые счетчики в конце лога могут быть некорректными (нулевыми). Это не влияет на сам процесс проверки в dry-run.</p>

      <hr style="margin: 30px 0; border: 0; border-top: 1px solid var(--border-color);">

      <h3 id="mode-s3">--s3-bucket (Выгрузка в S3)</h3>
      <p>Скрипт может автоматически загружать локально скачанные файлы бэкапа в бакет Amazon S3, используя его как накапливающийся архив.</p>
      <p>Для включения выгрузки необходимо указать как минимум имя бакета. Используются следующие аргументы командной строки:</p>
      <ul>
        <li><code>--s3-bucket BUCKET_NAME</code><br> <strong>Обязательный для включения S3.</strong> Указывает имя целевого S3 бакета.</li>
        <li><code>--s3-prefix PREFIX</code><br> (Опционально) Указывает <strong>базовый</strong> префикс (путь внутри бакета), который будет использоваться. К нему автоматически добавляется имя диска. <br> Например, если указать <code>--s3-prefix drive_sync/</code>, то файлы My Drive попадут в <code>s3://BUCKET_NAME/drive_sync/My_Drive/</code>, а файлы Shared Drive "Marketing" - в <code>s3://BUCKET_NAME/drive_sync/Marketing/</code>. <br> Если префикс не указан, используется только имя диска (<code>s3://BUCKET_NAME/My_Drive/</code>, <code>s3://BUCKET_NAME/Marketing/</code>).</li>
      </ul>
      <h4>Пример запуска:</h4>
      <p>Выгрузка в бакет <code>my-gd-backups</code> с префиксом <code>drive_sync/</code>. <strong>Рекомендуется использовать совместно с <code>--incremental</code></strong>.</p>

      <h5>Без Docker:</h5>
      <pre><code class="language-bash"># Инкрементальный бэкап с выгрузкой в S3
python main.py --incremental --s3-bucket my-gd-backups --s3-prefix drive_sync/</code></pre>

      <h5>С Docker:</h5>
      <pre><code class="language-bash"># Инкрементальный бэкап с выгрузкой в S3
docker compose run --rm driveup python main.py --incremental --s3-bucket my-gd-backups --s3-prefix drive_sync/</code></pre>
      <div class="note">
        <p><strong>Настройка AWS Credentials:</strong> Для работы выгрузки в S3 необходимо, чтобы библиотека <code>boto3</code> (которую использует скрипт) могла найти учетные данные AWS. Настройте их стандартными для AWS SDK/CLI способами:</p>
        <ul>
            <li>Переменные окружения (<code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_SESSION_TOKEN</code>, <code>AWS_REGION</code>, <code>AWS_PROFILE</code>).</li>
            <li>Общий файл учетных данных (<code>~/.aws/credentials</code>).</li>
            <li>Общий файл конфигурации (<code>~/.aws/config</code>).</li>
            <li>IAM роль для EC2 инстанса или ECS задачи (рекомендуется для серверов).</li>
        </ul>
        <p>Убедитесь, что используемые учетные данные имеют права на запись (<code>s3:PutObject</code>) в указанный бакет. Если используется флаг <code>--s3-remove-local</code>, локальные файлы удаляются только после подтверждения успешной загрузки от S3.</p>
        <p>Убедитесь, что используемые учетные данные имеют права на запись (<code>s3:PutObject</code>) в указанный бакет.</p>
        <p>Скрипт <strong>не удаляет</strong> объекты из S3, даже если они были удалены из Google Drive. S3 используется как архив.</p>
      </div>

      <hr style="margin: 30px 0; border: 0; border-top: 1px solid var(--border-color);">

      <h3 id="mode-no-archive">--no-archive (Отключение архивации)</h3>
      <p>По умолчанию (если этот флаг <strong>не указан</strong>), после успешного завершения бэкапа (полного или инкрементального) скрипт создает <strong>ZIP-архив</strong> содержимого папки <code>BASE_DOWNLOAD_DIR</code> (куда скачивались файлы), а затем <strong>удаляет саму папку <code>BASE_DOWNLOAD_DIR</code></strong>.</p>
      <p>Флаг <code>--no-archive</code> отключает это поведение: ZIP-архив не создается, и папка <code>BASE_DOWNLOAD_DIR</code> с файлами бэкапа остается на месте.</p>
      <p>Используйте этот флаг, если вам нужна сама папка с файлами, а не ZIP-архив, или если вы управляете удалением папки/загрузкой в другое место самостоятельно.</p>

      <h4>Запуск без Docker:</h4>
      <pre><code class="language-bash"># Инкрементальный бэкап без последующей архивации
python main.py --incremental --no-archive</code></pre>

      <h4>Запуск с Docker:</h4>
      <pre><code class="language-bash"># Инкрементальный бэкап без последующей архивации
docker compose run --rm driveup python main.py --incremental --no-archive</code></pre>

      
      <h2 id="configuration">Конфигурация (.env)</h2>
      <p>Основные параметры скрипта настраиваются через переменные окружения. Рекомендуемый способ — создать файл <code>.env</code> в <strong>корневой директории проекта</strong> (там же, где <code>main.py</code>).</p>
      <p>Пример файла <code>.env</code>:</p>
      <pre><code class="language-ini"># --- Файлы учетных данных и токенов ---
CREDENTIALS_FILE=credentials.json
TOKEN_FILE=token.json

# --- Директории ---
# Куда скачивать файлы с Google Drive
BASE_DOWNLOAD_DIR=driveup_backup
# Где хранить файлы состояния (токены, карты ID-путь)
STATE_DIR=driveup_state
# Имя папки внутри BASE_DOWNLOAD_DIR/My_Drive/ для осиротевших файлов с Общих дисков
SHARED_FILES_DIR_NAME=Shared With Me
# Куда сохранять локальные ZIP-архивы (используется, только если S3 НЕ настроен)
# ARCHIVE_DIR=archive

# --- Имена файлов состояния (внутри STATE_DIR/[DriveName]/) ---
# Основная карта состояния {id: {name: ..., path: ...}}
STATE_MAP_FILENAME=drive_state.json
# Карта состояния для dry-run
STATE_MAP_DRY_RUN_FILENAME=drive_state_dry_run.json
# Файл с токеном изменений Changes API
START_TOKEN_FILENAME=start_token.txt

# --- Настройки API и Производительности ---
# Задержка между запросами к Sheets API при экспорте формул (для избежания квоты)
SHEETS_API_DELAY_SECONDS=2
# Макс. глубина рекурсии при восстановлении пути файла (защита от циклических ссылок)
MAX_PATH_RECONSTRUCTION_DEPTH=20

# --- Настройки Dry Run ---
# Кол-во случайных элементов для обработки в --dry-run
DRY_RUN_SAMPLE_SIZE=15
# Макс. размер файла (МБ) для скачивания в --dry-run (большие файлы пропускаются)
DRY_RUN_MAX_FILE_SIZE_MB=5

# --- Настройки логгера ---
# Уровень логирования: DEBUG, INFO, WARNING, ERROR, CRITICAL
LOG_LEVEL=INFO
# Файл для логов (если не указан, вывод в консоль)
# LOG_FILE=logs/backup.log</code></pre>
      <p>Описание переменных:</p>
      <ul>
        <li><code>CREDENTIALS_FILE</code>, <code>TOKEN_FILE</code>: Имена файлов учетных данных Google OAuth.</li>
        <li><code>BASE_DOWNLOAD_DIR</code>: Корневая папка для скачанных файлов бэкапа.</li>
        <li><code>STATE_DIR</code>: Папка для хранения файлов состояния (токен изменений, карта ID-путь).</li>
        <li><code>SHARED_FILES_DIR_NAME</code>: Имя подпапки внутри `BASE_DOWNLOAD_DIR/My_Drive/`, куда помещаются файлы/папки, найденные при синхронизации "Моего диска", но принадлежащие Общим дискам, которые не обрабатываются отдельно (например, пользователь потерял к ним доступ). По умолчанию "Shared With Me".</li>
        <li><code>ARCHIVE_DIR</code>: Папка для локальных ZIP-архивов. Используется <strong>только</strong> если выгрузка в S3 <strong>не</strong> включена (т.е. не указан <code>--s3-bucket</code>) и флаг <code>--no-archive</code> <strong>не</strong> используется. Если путь не указан или закомментирован, архивы могут сохраняться в текущей рабочей директории или не создаваться вовсе, в зависимости от реализации функции архивации.</li>
        <li><code>STATE_MAP_FILENAME</code>, <code>STATE_MAP_DRY_RUN_FILENAME</code>, <code>START_TOKEN_FILENAME</code>: Имена файлов состояния внутри подпапок <code>STATE_DIR</code>.</li>
        <li><code>SHEETS_API_DELAY_SECONDS</code>: Задержка между запросами к Sheets API.</li>
        <li><code>MAX_PATH_RECONSTRUCTION_DEPTH</code>: Ограничение глубины поиска родительских папок.</li>
        <li><code>DRY_RUN_SAMPLE_SIZE</code>, <code>DRY_RUN_MAX_FILE_SIZE_MB</code>: Параметры тестового режима.</li>
        <li><code>LOG_LEVEL</code>: Уровень детализации логов (<code>INFO</code> - стандартный, <code>DEBUG</code> - подробный).</li>
        <li><code>LOG_FILE</code>: (Опционально) Путь к файлу, куда будут записываться логи. <br> Если не указан, логи выводятся в консоль (stdout/stderr). <br> При запуске через cron или Docker рекомендуется указывать файл логов.</li>
      </ul>
      <p><strong>Учетные данные AWS для S3</strong> настраиваются <strong>вне</strong> файла <code>.env</code> стандартными способами, как описано в разделе <a href="#mode-s3">Выгрузка в S3</a>.</p>

      
      <h2 id="project-structure">Структура проекта</h2>
      <p>После рефакторинга код организован следующим образом:</p>
      <pre><code class="plaintext">.
├── .env                 # Файл конфигурации (создается вручную)
├── credentials.json     # Учетные данные Google API (скачивается)
├── token.json           # Токен авторизации (генерируется при первом запуске)
├── main.py              # Точка входа, парсинг аргументов, orchestrator
├── Dockerfile           # Инструкции для сборки Docker-образа
├── docker-compose.yml   # Конфигурация для запуска через Docker Compose
├── requirements.txt     # Список Python-зависимостей
├── src/                 # Папка с исходным кодом модулей
│   ├── __init__.py
│   ├── config.py        # Загрузка .env, константы, логгер
│   ├── utils.py         # Вспомогательные функции
│   ├── state_manager.py # Управление файлами состояния
│   ├── google_api.py    # Аутентификация, работа с Google API
│   ├── file_processor.py# Скачивание, экспорт, обработка Sheets, S3
│   ├── sync.py          # Логика полной и инкрементальной синхронизации
│   └── archive.py       # Создание и очистка ZIP-архивов
├── driveup_backup/      # Папка для скачанных файлов (имя из .env)
│   ├── My_Drive/
│   └── Shared_Drive_Name/
├── driveup_state/       # Папка для файлов состояния (имя из .env)
│   ├── My_Drive/
│   │   ├── drive_state.json
│   │   └── start_token.txt
│   └── Shared_Drive_Name/
│       ├── drive_state.json
│       └── start_token.txt
└── archive/             # Папка для локальных архивов (имя из .env)
    └── drive_backup_YYYYMMDD_HHMMSS.zip</code></pre>

      
      <h2 id="state-management">Управление состоянием</h2>
      <p>Для корректной работы инкрементальных бэкапов и отслеживания изменений скрипт использует файлы состояния, которые хранятся в <strong>специальной директории состояния</strong> (путь задается переменной <code>STATE_DIR</code> в <code>.env</code>, по умолчанию <code>driveup_state</code>).</p>
      <p>Внутри этой директории создаются подпапки для каждого диска (например, <code>driveup_state/My_Drive/</code>, <code>driveup_state/Shared_Drive_Name/</code>), где и хранятся соответствующие файлы:</p>
      <ul>
        <li>
          <p><code>{STATE_MAP_FILENAME}</code> (по умолч. <code>drive_state.json</code>)</p>
          <p>Основная "карта состояния" для диска. Это JSON-файл, хранящий словарь, где ключи — это ID файлов/папок на Google Drive, а значения — информация о них (имя, ID родительской папки, локальный путь, MD5 хэш для файлов и т.д.). <br> Эта карта используется для определения локального пути при обработке изменений (перемещения, удаления) и для проверки актуальности скачанных файлов.</p>
        </li>
        <li>
          <p><code>{START_TOKEN_FILENAME}</code> (по умолч. <code>start_token.txt</code>)</p>
          <p>Хранит последний "токен изменений" (PageToken), полученный от Google Drive Changes API для данного диска. Этот токен используется при следующем запуске для запроса только новых изменений (см. <a href="#how-it-works">Принцип работы</a>).</p>
        </li>
        <li>
          <p><code>{STATE_MAP_DRY_RUN_FILENAME}</code> (по умолч. <code>drive_state_dry_run.json</code>)</p>
          <p>Аналог <code>drive_state.json</code>, но создается и используется только при запуске с флагом <code>--dry-run</code>, чтобы не влиять на основное состояние.</p>
        </li>
      </ul>
      <div class="note">
        <p><strong>Важно:</strong></p>
        <ul>
            <li>Папка с реальными скачанными файлами (<code>BASE_DOWNLOAD_DIR</code>, по умолч. <code>driveup_backup</code>) <strong>не содержит</strong> файлов состояния.</li>
            <li><strong>Не удаляйте папку состояния (<code>STATE_DIR</code>) и ее содержимое</strong>, если вы хотите, чтобы инкрементальные бэкапы продолжали работать эффективно. Удаление этих файлов приведет к необходимости полной синхронизации при следующем запуске.</li>
            <li>Вы можете безопасно архивировать или удалять содержимое папки <code>BASE_DOWNLOAD_DIR</code> после каждого бэкапа (например, если вы используете S3 с опцией <code>--s3-remove-local</code>), не опасаясь нарушить механизм инкрементального бэкапа.</li>
            <li>При настройке автоматического запуска (cron, Docker) убедитесь, что процесс имеет права на чтение и запись как в папку данных (<code>BASE_DOWNLOAD_DIR</code>), так и в папку состояния (<code>STATE_DIR</code>).</li>
        </ul>
      </div>

      
      <h2 id="technical-details">Технические детали</h2>

      <h3 id="api-limits">Ограничения API Google Drive</h3>
      <p>При работе с Google Drive API важно помнить об ограничениях:</p>
      <ul>
        <li><strong>Лимит на экспорт (10 МБ):</strong> Google Drive API имеет ограничение в <strong>10 МБ</strong> на размер <strong>итогового файла</strong> при экспорте (конвертации) документов из форматов Google Workspace (Docs, Sheets, Slides, Drawings) в другие форматы (<code>.docx</code>, <code>.xlsx</code>, <code>.pptx</code>, <code>.png</code>). Это ограничение относится к вызову <code>service.files().export_media(...)</code>. <br> Если экспорт не удается из-за размера, скрипт запишет ошибку в лог и пропустит файл. Сам файл Google в этом случае не будет сохранен в экспортированном формате.</li>
        <li><strong>Прямое скачивание:</strong> Лимит <strong>не распространяется</strong> на прямое скачивание файлов, которые уже хранятся на Диске в своем исходном формате (PDF, изображения, видео, архивы и т.д.), а также на Google Apps Script файлы. <br> Для них используется метод <code>service.files().get_media(...)</code>, который поддерживает скачивание файлов большого размера.</li>
        <li><strong>Квоты на запросы:</strong> Google API имеет <a href="https://developers.google.com/drive/api/guides/limits" target="_blank">лимиты на количество запросов</a> в единицу времени. Скрипт использует Changes API для минимизации запросов, но при очень большом количестве изменений или при первичной синхронизации больших дисков можно столкнуться с временными ошибками квоты (Rate Limit Exceeded). <br> Скрипт имеет базовый механизм повторных попыток (retry) с экспоненциальной задержкой для некоторых операций, но постоянные ошибки могут требовать увеличения интервала между запусками бэкапа. <br> Увеличение <code>SHEETS_API_DELAY_SECONDS</code> в <code>.env</code> может помочь при экспорте формул из большого количества таблиц.</li>
      </ul>

      
      <h2 id="troubleshooting">Возможные Проблемы и Решения</h2>
      <ul>
        <li><strong>Ошибка `NameError: name 'Any' is not defined` при запуске:</strong> <br> Проблема с импортом в `main.py`. Убедитесь, что в начале `main.py` есть строка `from typing import Optional, Set, Any`.</li>
        <li><strong>Ошибка при запуске `python main.py`: `error: the following arguments are required: --full/--incremental`</strong> <br> Необходимо явно указать режим работы. Используйте `python main.py --full` для полной синхронизации или `python main.py --incremental` для инкрементальной.</li>
        <li><strong>Первый запуск очень долгий:</strong><br>
           Нормально для больших дисков. Идет полная синхронизация (даже если вы указали <code>--incremental</code>, но нет файлов состояния). <br> Последующие запуски с <code>--incremental</code> будут быстрыми. <br>Используйте <code>--dry-run</code> для быстрой проверки конфигурации.</li>
        <li><strong>Запрос авторизации при каждом запуске / Токен "протухает" каждые 7 дней:</strong><br>
           Наиболее вероятная причина: ваше приложение в Google Cloud Console находится в статусе "Тестирование". <br> Перейдите в "API и сервисы" &rarr; "Экран согласия OAuth" и нажмите <strong>"Опубликовать приложение"</strong>. <br> После этого <strong>удалите старый файл <code>token.json</code></strong> и пройдите <a href="#first-auth">авторизацию</a> заново один раз.</li>
        <li><strong>Ошибка "Access blocked: ... is restricted" (Error 403: org_internal) при первой авторизации:</strong><br>
           Экран согласия OAuth настроен как "Внутренний", а вы входите с внешнего аккаунта. Измените тип на "Внешний" в Google Cloud Console, удалите <code>token.json</code> и авторизуйтесь снова.</li>
        <li><strong>Ошибка 403 Forbidden / Insufficient Permission / cannotDownloadFile при скачивании/экспорте файла:</strong> <br>
            <ul>
                <li>Проверьте, включены ли API Drive и Sheets в Google Cloud Console.</li>
                <li>Убедитесь, что бэкапер дал все запрошенные разрешения при первой авторизации.</li>
                <li><strong>Для Общих дисков:</strong> бэкапер должен быть участником диска (минимум с правами читателя).</li>
                <li><strong>Для расшаренных файлов/папок (особенно с `cannotDownloadFile`):</strong> Владелец файла должен в настройках доступа (<svg viewBox="0 0 16 16" fill="currentColor" style="width:1em; height:1em; vertical-align: text-bottom;"><path fill-rule="evenodd" d="M8.84 0.018a6.932 6.932 0 0 1 2.601.444l.27.108a.5.5 0 0 1 .289.648l-.073.182a.5.5 0 0 1-.648.288l-.27-.108a5.932 5.932 0 0 0-2.22-.374V1.5c0 .276-.224.5-.5.5S7.5 1.776 7.5 1.5V0.5c0-.276.224-.5.5-.5s.5.224.5.5v-.482ZM12.05 1.95a6.933 6.933 0 0 1 1.981 1.98l.108.27a.5.5 0 0 1-.288.648l-.182.073a.5.5 0 0 1-.648-.289l-.108-.27a5.932 5.932 0 0 0-1.69-.69l.181-.073a.5.5 0 0 1 .289-.648l-.108-.27Zm-8.1 0-.108.27a.5.5 0 0 1-.288.648l-.182.073a.5.5 0 0 1-.648-.288l-.108-.27a5.932 5.932 0 0 0-1.69 1.69l-.073.182a.5.5 0 0 1-.648.289L0 3.95a.5.5 0 0 1-.288-.648l.108-.27A6.932 6.932 0 0 1 1.95 1.95l.27-.108a.5.5 0 0 1 .648.289l.073.182a.5.5 0 0 1-.288.648l-.27.108Zm9.168 9.168.27.108a.5.5 0 0 1 .288.648l-.073.182a.5.5 0 0 1-.648.288l-.27-.108a5.932 5.932 0 0 0-1.69 1.69l-.182.073a.5.5 0 0 1-.648.289l-.27-.108a6.932 6.932 0 0 1-1.98-1.98l-.108-.27a.5.5 0 0 1 .288-.648l.182-.073a.5.5 0 0 1 .648.289l.108.27a5.932 5.932 0 0 0 1.69 1.69Zm-9.168 0a5.932 5.932 0 0 0 1.69-1.69l.108-.27a.5.5 0 0 1 .648-.289l.182.073a.5.5 0 0 1 .288.648l-.108.27a6.932 6.932 0 0 1-1.98 1.98l-.27.108a.5.5 0 0 1-.648-.288l-.073-.182a.5.5 0 0 1 .288-.648l.27-.108Zm-1.5-4.618V8.5c0 .276.224.5.5.5s.5-.224.5-.5V7.5c0-.276-.224-.5-.5-.5s-.5.224-.5.5Zm13 0V8.5c0 .276-.224.5-.5.5s-.5-.224-.5-.5V7.5c0-.276.224-.5.5-.5s.5.224.5.5Zm-6.5 8v-1c0-.276.224-.5.5-.5s.5.224.5.5v1c0 .276-.224-.5-.5.5s-.5-.224-.5-.5Zm0-13.982V1.5c0-.276-.224-.5-.5-.5S7.5 1.224 7.5 1.5v.518a6.932 6.932 0 0 1-2.601.444l-.27.108a.5.5 0 0 1-.288.648l.073.182a.5.5 0 0 1 .648.288l.27-.108a5.932 5.932 0 0 0 2.22-.374V3c0 .276.224.5.5.5s.5-.224.5-.5V2.518a5.932 5.932 0 0 0 2.22.374l.27.108a.5.5 0 0 1 .648-.288l.073-.182a.5.5 0 0 1-.288-.648l-.27-.108A6.932 6.932 0 0 1 8.5.018ZM8 4a4 4 0 1 1 0 8 4 4 0 0 1 0-8Zm0 1a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z" clip-rule="evenodd"></path></svg> шестеренка) <strong>явно разрешить скачивание</strong> ("Разрешить читателям и комментаторам скачивать..."). <br> Также, бэкапер должен добавить ярлык на этот файл/папку в свой "Мой диск".</li>
                <li>Попробуйте удалить <code>token.json</code> и пройти авторизацию заново.</li>
            </ul>
        </li>
        <li><strong>Ошибка "pageToken not found" / "404 Not Found" при запросе изменений (`changes.list`):</strong> <br> Токен изменений (<code>start_token.txt</code>) устарел. <br> Скрипт автоматически обнаружит это, удалит старые файлы состояния для этого диска (<code>start_token.txt</code>, <code>drive_state.json</code>) и выполнит <strong>полную синхронизацию</strong> при следующем запуске.</li>
        <li><strong>Предупреждение "Parent ... for item ... not found in item list" при полной синхронизации:</strong> <br> Скрипт не смог найти информацию о родительской папке для элемента при полном сканировании. Такое бывает с "осиротевшими" файлами. <br> Файл будет сохранен в корне папки бэкапа для данного диска.</li>
        <li><strong>Предупреждение "Broken pipe", "Connection reset by peer" при скачивании:</strong> <br> Временный сбой сети. Скрипт имеет механизм повторных попыток и часто успешно завершает скачивание.</li>
        <li><strong>Неверная итоговая статистика при Dry Run + Full Sync:</strong> <br> Ошибка в логике суммирования статистики для этого специфического сценария.</li>
        <li><strong>Ошибки квоты (Quota Exceeded / Rate Limit Exceeded):</strong> <br> См. <a href="#api-limits">Ограничения API</a>. Может потребоваться увеличить интервал между запусками бэкапа.</li>
        <li><strong>Не экспортируются большие файлы Google Docs/Sheets/Slides:</strong> <br> Связано с лимитом на экспорт в 10 МБ (см. <a href="#api-limits">Ограничения API</a>).</li>
        <li><strong>Ошибки при выгрузке в S3 (NoCredentialsError, ClientError):</strong> <br> Проверьте настройку учетных данных AWS, наличие <code>boto3</code>, существование бакета и права на запись (<code>s3:PutObject</code>).</li>
        <li><strong>Скрипт не запускается через cron:</strong> <br> Проверьте полные пути в crontab, использование python из venv, права доступа к файлам/папкам, системные логи cron.</li>
        <li><strong>Файл <code>drive_state.json</code> сильно разрастается:</strong> <br> Нормально, он хранит информацию о всех файлах/папках в бэкапе для восстановления структуры и проверки изменений.</li>
      </ul>

      <p style="text-align: center; margin-top: 80px;">
        <a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ" target="_blank" rel="noopener noreferrer" title="..." style="font-size: 1em; text-decoration: none;">¯\_(ツ)_/¯</a>
      </p>

    </main> 

  </div> 

  <script>
    const themeToggle = document.getElementById('theme-toggle');
    const body = document.body;
    const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');

    function applyTheme(theme) {
      if (theme === 'dark') {
        body.classList.add('dark-theme');
      } else {
        body.classList.remove('dark-theme');
      }
    }

    function toggleTheme() {
      const currentThemeIsDark = body.classList.contains('dark-theme');
      const newTheme = currentThemeIsDark ? 'light' : 'dark';
      applyTheme(newTheme);
      try {
        localStorage.setItem('theme', newTheme);
      } catch (e) {
        console.warn('LocalStorage не доступен для сохранения темы', e);
      }
    }

    let savedTheme;
    try {
      savedTheme = localStorage.getItem('theme');
    } catch (e) {
      console.warn('LocalStorage не доступен для загрузки темы', e);
      savedTheme = null;
    }

    const initialTheme = savedTheme ? savedTheme : (prefersDarkScheme.matches ? 'dark' : 'light');
    applyTheme(initialTheme);

    themeToggle.addEventListener('click', toggleTheme);

    prefersDarkScheme.addEventListener('change', (e) => {
      let currentSavedTheme;
      try {
        currentSavedTheme = localStorage.getItem('theme');
      } catch (err) {
        currentSavedTheme = null;
      }

      if (!currentSavedTheme) {
        applyTheme(e.matches ? 'dark' : 'light');
      }
    });
  </script>

</body>

</html>
